# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ProjectArgs', 'Project']

@pulumi.input_type
class ProjectArgs:
    def __init__(__self__, *,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_ips_protected_branches_only: Optional[pulumi.Input[_builtins.str]] = None,
                 branch: Optional[pulumi.Input['ProjectBranchArgs']] = None,
                 compute_provisioner: Optional[pulumi.Input[_builtins.str]] = None,
                 default_endpoint_settings: Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']] = None,
                 enable_logical_replication: Optional[pulumi.Input[_builtins.str]] = None,
                 history_retention_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pg_version: Optional[pulumi.Input[_builtins.float]] = None,
                 quota: Optional[pulumi.Input['ProjectQuotaArgs']] = None,
                 region_id: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a Project resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
               Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        :param pulumi.Input[_builtins.str] allowed_ips_protected_branches_only: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
               protected branches only. Note that the feature is available to the Neon Scale plans only.
        :param pulumi.Input[_builtins.str] compute_provisioner: Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
               Autoscaling.
        :param pulumi.Input[_builtins.str] enable_logical_replication: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
               all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
               be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        :param pulumi.Input[_builtins.float] history_retention_seconds: The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
               https://neon.tech/docs/reference/glossary#point-in-time-restore.
        :param pulumi.Input[_builtins.str] name: Project name.
        :param pulumi.Input[_builtins.str] org_id: Identifier of the organisation to which this project belongs.
        :param pulumi.Input[_builtins.float] pg_version: Postgres version
        :param pulumi.Input['ProjectQuotaArgs'] quota: Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
               be possible to start them with an API method call or incoming proxy connections. The only exception is
               logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
               logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
               which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
               this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
               means 'unlimited'.
        :param pulumi.Input[_builtins.str] region_id: Deployment region: https://neon.tech/docs/introduction/regions
        :param pulumi.Input[_builtins.str] store_password: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
               are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
               authorization.
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if allowed_ips_protected_branches_only is not None:
            pulumi.set(__self__, "allowed_ips_protected_branches_only", allowed_ips_protected_branches_only)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if compute_provisioner is not None:
            pulumi.set(__self__, "compute_provisioner", compute_provisioner)
        if default_endpoint_settings is not None:
            pulumi.set(__self__, "default_endpoint_settings", default_endpoint_settings)
        if enable_logical_replication is not None:
            pulumi.set(__self__, "enable_logical_replication", enable_logical_replication)
        if history_retention_seconds is not None:
            pulumi.set(__self__, "history_retention_seconds", history_retention_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
        Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="allowedIpsProtectedBranchesOnly")
    def allowed_ips_protected_branches_only(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
        protected branches only. Note that the feature is available to the Neon Scale plans only.
        """
        return pulumi.get(self, "allowed_ips_protected_branches_only")

    @allowed_ips_protected_branches_only.setter
    def allowed_ips_protected_branches_only(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allowed_ips_protected_branches_only", value)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input['ProjectBranchArgs']]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input['ProjectBranchArgs']]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="computeProvisioner")
    def compute_provisioner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
        Autoscaling.
        """
        return pulumi.get(self, "compute_provisioner")

    @compute_provisioner.setter
    def compute_provisioner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compute_provisioner", value)

    @_builtins.property
    @pulumi.getter(name="defaultEndpointSettings")
    def default_endpoint_settings(self) -> Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']]:
        return pulumi.get(self, "default_endpoint_settings")

    @default_endpoint_settings.setter
    def default_endpoint_settings(self, value: Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']]):
        pulumi.set(self, "default_endpoint_settings", value)

    @_builtins.property
    @pulumi.getter(name="enableLogicalReplication")
    def enable_logical_replication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
        all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
        be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        """
        return pulumi.get(self, "enable_logical_replication")

    @enable_logical_replication.setter
    def enable_logical_replication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_logical_replication", value)

    @_builtins.property
    @pulumi.getter(name="historyRetentionSeconds")
    def history_retention_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
        https://neon.tech/docs/reference/glossary#point-in-time-restore.
        """
        return pulumi.get(self, "history_retention_seconds")

    @history_retention_seconds.setter
    def history_retention_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "history_retention_seconds", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the organisation to which this project belongs.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Postgres version
        """
        return pulumi.get(self, "pg_version")

    @pg_version.setter
    def pg_version(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "pg_version", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['ProjectQuotaArgs']]:
        """
        Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
        be possible to start them with an API method call or incoming proxy connections. The only exception is
        logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
        logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
        which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
        this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
        means 'unlimited'.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['ProjectQuotaArgs']]):
        pulumi.set(self, "quota", value)

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deployment region: https://neon.tech/docs/introduction/regions
        """
        return pulumi.get(self, "region_id")

    @region_id.setter
    def region_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region_id", value)

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
        are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
        authorization.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_password", value)


@pulumi.input_type
class _ProjectState:
    def __init__(__self__, *,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_ips_protected_branches_only: Optional[pulumi.Input[_builtins.str]] = None,
                 branch: Optional[pulumi.Input['ProjectBranchArgs']] = None,
                 compute_provisioner: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_uri_pooler: Optional[pulumi.Input[_builtins.str]] = None,
                 database_host: Optional[pulumi.Input[_builtins.str]] = None,
                 database_host_pooler: Optional[pulumi.Input[_builtins.str]] = None,
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 database_password: Optional[pulumi.Input[_builtins.str]] = None,
                 database_user: Optional[pulumi.Input[_builtins.str]] = None,
                 default_branch_id: Optional[pulumi.Input[_builtins.str]] = None,
                 default_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 default_endpoint_settings: Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']] = None,
                 enable_logical_replication: Optional[pulumi.Input[_builtins.str]] = None,
                 history_retention_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pg_version: Optional[pulumi.Input[_builtins.float]] = None,
                 quota: Optional[pulumi.Input['ProjectQuotaArgs']] = None,
                 region_id: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering Project resources.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
               Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        :param pulumi.Input[_builtins.str] allowed_ips_protected_branches_only: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
               protected branches only. Note that the feature is available to the Neon Scale plans only.
        :param pulumi.Input[_builtins.str] compute_provisioner: Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
               Autoscaling.
        :param pulumi.Input[_builtins.str] connection_uri: Default connection uri. **Note** that it contains access credentials.
        :param pulumi.Input[_builtins.str] connection_uri_pooler: Default connection uri with the traffic via pooler. **Note** that it contains access credentials.
        :param pulumi.Input[_builtins.str] database_host: Default database host.
        :param pulumi.Input[_builtins.str] database_host_pooler: Default endpoint host via pooler.
        :param pulumi.Input[_builtins.str] database_name: Default database name.
        :param pulumi.Input[_builtins.str] database_password: Default database access password.
        :param pulumi.Input[_builtins.str] database_user: Default database role.
        :param pulumi.Input[_builtins.str] default_branch_id: Default branch ID.
        :param pulumi.Input[_builtins.str] default_endpoint_id: Default endpoint ID.
        :param pulumi.Input[_builtins.str] enable_logical_replication: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
               all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
               be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        :param pulumi.Input[_builtins.float] history_retention_seconds: The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
               https://neon.tech/docs/reference/glossary#point-in-time-restore.
        :param pulumi.Input[_builtins.str] name: Project name.
        :param pulumi.Input[_builtins.str] org_id: Identifier of the organisation to which this project belongs.
        :param pulumi.Input[_builtins.float] pg_version: Postgres version
        :param pulumi.Input['ProjectQuotaArgs'] quota: Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
               be possible to start them with an API method call or incoming proxy connections. The only exception is
               logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
               logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
               which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
               this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
               means 'unlimited'.
        :param pulumi.Input[_builtins.str] region_id: Deployment region: https://neon.tech/docs/introduction/regions
        :param pulumi.Input[_builtins.str] store_password: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
               are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
               authorization.
        """
        if allowed_ips is not None:
            pulumi.set(__self__, "allowed_ips", allowed_ips)
        if allowed_ips_protected_branches_only is not None:
            pulumi.set(__self__, "allowed_ips_protected_branches_only", allowed_ips_protected_branches_only)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if compute_provisioner is not None:
            pulumi.set(__self__, "compute_provisioner", compute_provisioner)
        if connection_uri is not None:
            pulumi.set(__self__, "connection_uri", connection_uri)
        if connection_uri_pooler is not None:
            pulumi.set(__self__, "connection_uri_pooler", connection_uri_pooler)
        if database_host is not None:
            pulumi.set(__self__, "database_host", database_host)
        if database_host_pooler is not None:
            pulumi.set(__self__, "database_host_pooler", database_host_pooler)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_password is not None:
            pulumi.set(__self__, "database_password", database_password)
        if database_user is not None:
            pulumi.set(__self__, "database_user", database_user)
        if default_branch_id is not None:
            pulumi.set(__self__, "default_branch_id", default_branch_id)
        if default_endpoint_id is not None:
            pulumi.set(__self__, "default_endpoint_id", default_endpoint_id)
        if default_endpoint_settings is not None:
            pulumi.set(__self__, "default_endpoint_settings", default_endpoint_settings)
        if enable_logical_replication is not None:
            pulumi.set(__self__, "enable_logical_replication", enable_logical_replication)
        if history_retention_seconds is not None:
            pulumi.set(__self__, "history_retention_seconds", history_retention_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
        Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        """
        return pulumi.get(self, "allowed_ips")

    @allowed_ips.setter
    def allowed_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ips", value)

    @_builtins.property
    @pulumi.getter(name="allowedIpsProtectedBranchesOnly")
    def allowed_ips_protected_branches_only(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
        protected branches only. Note that the feature is available to the Neon Scale plans only.
        """
        return pulumi.get(self, "allowed_ips_protected_branches_only")

    @allowed_ips_protected_branches_only.setter
    def allowed_ips_protected_branches_only(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allowed_ips_protected_branches_only", value)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input['ProjectBranchArgs']]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input['ProjectBranchArgs']]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="computeProvisioner")
    def compute_provisioner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
        Autoscaling.
        """
        return pulumi.get(self, "compute_provisioner")

    @compute_provisioner.setter
    def compute_provisioner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compute_provisioner", value)

    @_builtins.property
    @pulumi.getter(name="connectionUri")
    def connection_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default connection uri. **Note** that it contains access credentials.
        """
        return pulumi.get(self, "connection_uri")

    @connection_uri.setter
    def connection_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_uri", value)

    @_builtins.property
    @pulumi.getter(name="connectionUriPooler")
    def connection_uri_pooler(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default connection uri with the traffic via pooler. **Note** that it contains access credentials.
        """
        return pulumi.get(self, "connection_uri_pooler")

    @connection_uri_pooler.setter
    def connection_uri_pooler(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_uri_pooler", value)

    @_builtins.property
    @pulumi.getter(name="databaseHost")
    def database_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default database host.
        """
        return pulumi.get(self, "database_host")

    @database_host.setter
    def database_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_host", value)

    @_builtins.property
    @pulumi.getter(name="databaseHostPooler")
    def database_host_pooler(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default endpoint host via pooler.
        """
        return pulumi.get(self, "database_host_pooler")

    @database_host_pooler.setter
    def database_host_pooler(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_host_pooler", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="databasePassword")
    def database_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default database access password.
        """
        return pulumi.get(self, "database_password")

    @database_password.setter
    def database_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_password", value)

    @_builtins.property
    @pulumi.getter(name="databaseUser")
    def database_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default database role.
        """
        return pulumi.get(self, "database_user")

    @database_user.setter
    def database_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_user", value)

    @_builtins.property
    @pulumi.getter(name="defaultBranchId")
    def default_branch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default branch ID.
        """
        return pulumi.get(self, "default_branch_id")

    @default_branch_id.setter
    def default_branch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_branch_id", value)

    @_builtins.property
    @pulumi.getter(name="defaultEndpointId")
    def default_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default endpoint ID.
        """
        return pulumi.get(self, "default_endpoint_id")

    @default_endpoint_id.setter
    def default_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="defaultEndpointSettings")
    def default_endpoint_settings(self) -> Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']]:
        return pulumi.get(self, "default_endpoint_settings")

    @default_endpoint_settings.setter
    def default_endpoint_settings(self, value: Optional[pulumi.Input['ProjectDefaultEndpointSettingsArgs']]):
        pulumi.set(self, "default_endpoint_settings", value)

    @_builtins.property
    @pulumi.getter(name="enableLogicalReplication")
    def enable_logical_replication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
        all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
        be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        """
        return pulumi.get(self, "enable_logical_replication")

    @enable_logical_replication.setter
    def enable_logical_replication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_logical_replication", value)

    @_builtins.property
    @pulumi.getter(name="historyRetentionSeconds")
    def history_retention_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
        https://neon.tech/docs/reference/glossary#point-in-time-restore.
        """
        return pulumi.get(self, "history_retention_seconds")

    @history_retention_seconds.setter
    def history_retention_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "history_retention_seconds", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the organisation to which this project belongs.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org_id", value)

    @_builtins.property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Postgres version
        """
        return pulumi.get(self, "pg_version")

    @pg_version.setter
    def pg_version(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "pg_version", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['ProjectQuotaArgs']]:
        """
        Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
        be possible to start them with an API method call or incoming proxy connections. The only exception is
        logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
        logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
        which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
        this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
        means 'unlimited'.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['ProjectQuotaArgs']]):
        pulumi.set(self, "quota", value)

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deployment region: https://neon.tech/docs/introduction/regions
        """
        return pulumi.get(self, "region_id")

    @region_id.setter
    def region_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region_id", value)

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
        are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
        authorization.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_password", value)


@pulumi.type_token("neon:index/project:Project")
class Project(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_ips_protected_branches_only: Optional[pulumi.Input[_builtins.str]] = None,
                 branch: Optional[pulumi.Input[Union['ProjectBranchArgs', 'ProjectBranchArgsDict']]] = None,
                 compute_provisioner: Optional[pulumi.Input[_builtins.str]] = None,
                 default_endpoint_settings: Optional[pulumi.Input[Union['ProjectDefaultEndpointSettingsArgs', 'ProjectDefaultEndpointSettingsArgsDict']]] = None,
                 enable_logical_replication: Optional[pulumi.Input[_builtins.str]] = None,
                 history_retention_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pg_version: Optional[pulumi.Input[_builtins.float]] = None,
                 quota: Optional[pulumi.Input[Union['ProjectQuotaArgs', 'ProjectQuotaArgsDict']]] = None,
                 region_id: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Create a Project resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
               Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        :param pulumi.Input[_builtins.str] allowed_ips_protected_branches_only: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
               protected branches only. Note that the feature is available to the Neon Scale plans only.
        :param pulumi.Input[_builtins.str] compute_provisioner: Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
               Autoscaling.
        :param pulumi.Input[_builtins.str] enable_logical_replication: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
               all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
               be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        :param pulumi.Input[_builtins.float] history_retention_seconds: The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
               https://neon.tech/docs/reference/glossary#point-in-time-restore.
        :param pulumi.Input[_builtins.str] name: Project name.
        :param pulumi.Input[_builtins.str] org_id: Identifier of the organisation to which this project belongs.
        :param pulumi.Input[_builtins.float] pg_version: Postgres version
        :param pulumi.Input[Union['ProjectQuotaArgs', 'ProjectQuotaArgsDict']] quota: Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
               be possible to start them with an API method call or incoming proxy connections. The only exception is
               logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
               logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
               which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
               this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
               means 'unlimited'.
        :param pulumi.Input[_builtins.str] region_id: Deployment region: https://neon.tech/docs/introduction/regions
        :param pulumi.Input[_builtins.str] store_password: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
               are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
               authorization.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[ProjectArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a Project resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param ProjectArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ProjectArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_ips_protected_branches_only: Optional[pulumi.Input[_builtins.str]] = None,
                 branch: Optional[pulumi.Input[Union['ProjectBranchArgs', 'ProjectBranchArgsDict']]] = None,
                 compute_provisioner: Optional[pulumi.Input[_builtins.str]] = None,
                 default_endpoint_settings: Optional[pulumi.Input[Union['ProjectDefaultEndpointSettingsArgs', 'ProjectDefaultEndpointSettingsArgsDict']]] = None,
                 enable_logical_replication: Optional[pulumi.Input[_builtins.str]] = None,
                 history_retention_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 org_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pg_version: Optional[pulumi.Input[_builtins.float]] = None,
                 quota: Optional[pulumi.Input[Union['ProjectQuotaArgs', 'ProjectQuotaArgsDict']]] = None,
                 region_id: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ProjectArgs.__new__(ProjectArgs)

            __props__.__dict__["allowed_ips"] = allowed_ips
            __props__.__dict__["allowed_ips_protected_branches_only"] = allowed_ips_protected_branches_only
            __props__.__dict__["branch"] = branch
            __props__.__dict__["compute_provisioner"] = compute_provisioner
            __props__.__dict__["default_endpoint_settings"] = default_endpoint_settings
            __props__.__dict__["enable_logical_replication"] = enable_logical_replication
            __props__.__dict__["history_retention_seconds"] = history_retention_seconds
            __props__.__dict__["name"] = name
            __props__.__dict__["org_id"] = org_id
            __props__.__dict__["pg_version"] = pg_version
            __props__.__dict__["quota"] = quota
            __props__.__dict__["region_id"] = region_id
            __props__.__dict__["store_password"] = store_password
            __props__.__dict__["connection_uri"] = None
            __props__.__dict__["connection_uri_pooler"] = None
            __props__.__dict__["database_host"] = None
            __props__.__dict__["database_host_pooler"] = None
            __props__.__dict__["database_name"] = None
            __props__.__dict__["database_password"] = None
            __props__.__dict__["database_user"] = None
            __props__.__dict__["default_branch_id"] = None
            __props__.__dict__["default_endpoint_id"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["connectionUri", "connectionUriPooler", "databasePassword"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(Project, __self__).__init__(
            'neon:index/project:Project',
            resource_name,
            __props__,
            opts,
            package_ref=_utilities.get_package())

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allowed_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            allowed_ips_protected_branches_only: Optional[pulumi.Input[_builtins.str]] = None,
            branch: Optional[pulumi.Input[Union['ProjectBranchArgs', 'ProjectBranchArgsDict']]] = None,
            compute_provisioner: Optional[pulumi.Input[_builtins.str]] = None,
            connection_uri: Optional[pulumi.Input[_builtins.str]] = None,
            connection_uri_pooler: Optional[pulumi.Input[_builtins.str]] = None,
            database_host: Optional[pulumi.Input[_builtins.str]] = None,
            database_host_pooler: Optional[pulumi.Input[_builtins.str]] = None,
            database_name: Optional[pulumi.Input[_builtins.str]] = None,
            database_password: Optional[pulumi.Input[_builtins.str]] = None,
            database_user: Optional[pulumi.Input[_builtins.str]] = None,
            default_branch_id: Optional[pulumi.Input[_builtins.str]] = None,
            default_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
            default_endpoint_settings: Optional[pulumi.Input[Union['ProjectDefaultEndpointSettingsArgs', 'ProjectDefaultEndpointSettingsArgsDict']]] = None,
            enable_logical_replication: Optional[pulumi.Input[_builtins.str]] = None,
            history_retention_seconds: Optional[pulumi.Input[_builtins.float]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            org_id: Optional[pulumi.Input[_builtins.str]] = None,
            pg_version: Optional[pulumi.Input[_builtins.float]] = None,
            quota: Optional[pulumi.Input[Union['ProjectQuotaArgs', 'ProjectQuotaArgsDict']]] = None,
            region_id: Optional[pulumi.Input[_builtins.str]] = None,
            store_password: Optional[pulumi.Input[_builtins.str]] = None) -> 'Project':
        """
        Get an existing Project resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ips: A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
               Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        :param pulumi.Input[_builtins.str] allowed_ips_protected_branches_only: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
               protected branches only. Note that the feature is available to the Neon Scale plans only.
        :param pulumi.Input[_builtins.str] compute_provisioner: Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
               Autoscaling.
        :param pulumi.Input[_builtins.str] connection_uri: Default connection uri. **Note** that it contains access credentials.
        :param pulumi.Input[_builtins.str] connection_uri_pooler: Default connection uri with the traffic via pooler. **Note** that it contains access credentials.
        :param pulumi.Input[_builtins.str] database_host: Default database host.
        :param pulumi.Input[_builtins.str] database_host_pooler: Default endpoint host via pooler.
        :param pulumi.Input[_builtins.str] database_name: Default database name.
        :param pulumi.Input[_builtins.str] database_password: Default database access password.
        :param pulumi.Input[_builtins.str] database_user: Default database role.
        :param pulumi.Input[_builtins.str] default_branch_id: Default branch ID.
        :param pulumi.Input[_builtins.str] default_endpoint_id: Default endpoint ID.
        :param pulumi.Input[_builtins.str] enable_logical_replication: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
               all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
               be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        :param pulumi.Input[_builtins.float] history_retention_seconds: The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
               https://neon.tech/docs/reference/glossary#point-in-time-restore.
        :param pulumi.Input[_builtins.str] name: Project name.
        :param pulumi.Input[_builtins.str] org_id: Identifier of the organisation to which this project belongs.
        :param pulumi.Input[_builtins.float] pg_version: Postgres version
        :param pulumi.Input[Union['ProjectQuotaArgs', 'ProjectQuotaArgsDict']] quota: Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
               be possible to start them with an API method call or incoming proxy connections. The only exception is
               logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
               logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
               which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
               this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
               means 'unlimited'.
        :param pulumi.Input[_builtins.str] region_id: Deployment region: https://neon.tech/docs/introduction/regions
        :param pulumi.Input[_builtins.str] store_password: Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
               are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
               authorization.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ProjectState.__new__(_ProjectState)

        __props__.__dict__["allowed_ips"] = allowed_ips
        __props__.__dict__["allowed_ips_protected_branches_only"] = allowed_ips_protected_branches_only
        __props__.__dict__["branch"] = branch
        __props__.__dict__["compute_provisioner"] = compute_provisioner
        __props__.__dict__["connection_uri"] = connection_uri
        __props__.__dict__["connection_uri_pooler"] = connection_uri_pooler
        __props__.__dict__["database_host"] = database_host
        __props__.__dict__["database_host_pooler"] = database_host_pooler
        __props__.__dict__["database_name"] = database_name
        __props__.__dict__["database_password"] = database_password
        __props__.__dict__["database_user"] = database_user
        __props__.__dict__["default_branch_id"] = default_branch_id
        __props__.__dict__["default_endpoint_id"] = default_endpoint_id
        __props__.__dict__["default_endpoint_settings"] = default_endpoint_settings
        __props__.__dict__["enable_logical_replication"] = enable_logical_replication
        __props__.__dict__["history_retention_seconds"] = history_retention_seconds
        __props__.__dict__["name"] = name
        __props__.__dict__["org_id"] = org_id
        __props__.__dict__["pg_version"] = pg_version
        __props__.__dict__["quota"] = quota
        __props__.__dict__["region_id"] = region_id
        __props__.__dict__["store_password"] = store_password
        return Project(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="allowedIps")
    def allowed_ips(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        A list of IP addresses that are allowed to connect to the endpoints. Note that the feature is available to the Neon
        Scale plans only. Details: https://neon.tech/docs/manage/projects#configure-ip-allow
        """
        return pulumi.get(self, "allowed_ips")

    @_builtins.property
    @pulumi.getter(name="allowedIpsProtectedBranchesOnly")
    def allowed_ips_protected_branches_only(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Apply the allow-list to the
        protected branches only. Note that the feature is available to the Neon Scale plans only.
        """
        return pulumi.get(self, "allowed_ips_protected_branches_only")

    @_builtins.property
    @pulumi.getter
    def branch(self) -> pulumi.Output[Optional['outputs.ProjectBranch']]:
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="computeProvisioner")
    def compute_provisioner(self) -> pulumi.Output[_builtins.str]:
        """
        Provisioner The Neon compute provisioner. Specify the k8s-neonvm provisioner to create a compute endpoint that supports
        Autoscaling.
        """
        return pulumi.get(self, "compute_provisioner")

    @_builtins.property
    @pulumi.getter(name="connectionUri")
    def connection_uri(self) -> pulumi.Output[_builtins.str]:
        """
        Default connection uri. **Note** that it contains access credentials.
        """
        return pulumi.get(self, "connection_uri")

    @_builtins.property
    @pulumi.getter(name="connectionUriPooler")
    def connection_uri_pooler(self) -> pulumi.Output[_builtins.str]:
        """
        Default connection uri with the traffic via pooler. **Note** that it contains access credentials.
        """
        return pulumi.get(self, "connection_uri_pooler")

    @_builtins.property
    @pulumi.getter(name="databaseHost")
    def database_host(self) -> pulumi.Output[_builtins.str]:
        """
        Default database host.
        """
        return pulumi.get(self, "database_host")

    @_builtins.property
    @pulumi.getter(name="databaseHostPooler")
    def database_host_pooler(self) -> pulumi.Output[_builtins.str]:
        """
        Default endpoint host via pooler.
        """
        return pulumi.get(self, "database_host_pooler")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Output[_builtins.str]:
        """
        Default database name.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="databasePassword")
    def database_password(self) -> pulumi.Output[_builtins.str]:
        """
        Default database access password.
        """
        return pulumi.get(self, "database_password")

    @_builtins.property
    @pulumi.getter(name="databaseUser")
    def database_user(self) -> pulumi.Output[_builtins.str]:
        """
        Default database role.
        """
        return pulumi.get(self, "database_user")

    @_builtins.property
    @pulumi.getter(name="defaultBranchId")
    def default_branch_id(self) -> pulumi.Output[_builtins.str]:
        """
        Default branch ID.
        """
        return pulumi.get(self, "default_branch_id")

    @_builtins.property
    @pulumi.getter(name="defaultEndpointId")
    def default_endpoint_id(self) -> pulumi.Output[_builtins.str]:
        """
        Default endpoint ID.
        """
        return pulumi.get(self, "default_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="defaultEndpointSettings")
    def default_endpoint_settings(self) -> pulumi.Output[Optional['outputs.ProjectDefaultEndpointSettings']]:
        return pulumi.get(self, "default_endpoint_settings")

    @_builtins.property
    @pulumi.getter(name="enableLogicalReplication")
    def enable_logical_replication(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Sets wal_level=logical for
        all compute endpoints in this project. All active endpoints will be suspended. Once enabled, logical replication cannot
        be disabled. See details: https://neon.tech/docs/introduction/logical-replication
        """
        return pulumi.get(self, "enable_logical_replication")

    @_builtins.property
    @pulumi.getter(name="historyRetentionSeconds")
    def history_retention_seconds(self) -> pulumi.Output[Optional[_builtins.float]]:
        """
        The number of seconds to retain the point-in-time restore (PITR) backup history for this project. Default: 1 day, see
        https://neon.tech/docs/reference/glossary#point-in-time-restore.
        """
        return pulumi.get(self, "history_retention_seconds")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Project name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Identifier of the organisation to which this project belongs.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> pulumi.Output[_builtins.float]:
        """
        Postgres version
        """
        return pulumi.get(self, "pg_version")

    @_builtins.property
    @pulumi.getter
    def quota(self) -> pulumi.Output[Optional['outputs.ProjectQuota']]:
        """
        Per-project consumption quota. If the quota is exceeded, all active computes are automatically suspended and it will not
        be possible to start them with an API method call or incoming proxy connections. The only exception is
        logical_size_bytes, which is applied on per-branch basis, i.e., only the compute on the branch that exceeds the
        logical_size quota will be suspended. Quotas are enforced based on per-project consumption metrics with the same names,
        which are reset at the end of each billing period (the first day of the month). Logical size is also an exception in
        this case, as it represents the total size of data stored in a branch, so it is not reset. The zero value per attributed
        means 'unlimited'.
        """
        return pulumi.get(self, "quota")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> pulumi.Output[_builtins.str]:
        """
        Deployment region: https://neon.tech/docs/introduction/regions
        """
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Set to 'yes' to activate, 'no' to deactivate explicitly, and omit to keep the default value. Whether or not passwords
        are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require
        authorization.
        """
        return pulumi.get(self, "store_password")

